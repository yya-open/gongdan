
<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>工单记录系统（年度多维度增强版）</title>
<!-- 外部库：Excel 导出、ZIP 打包、统计图表 -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
    h1, h2, h3 { margin: 0 0 10px; }
    .card { background: #fff; padding: 16px; margin-bottom: 16px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.06); }
    form { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }
    form div { display: flex; flex-direction: column; }
    label { font-weight: bold; margin-bottom: 4px; }
    input, select, textarea { width: 100%; padding: 6px; box-sizing: border-box; }
    textarea { min-height: 60px; resize: vertical; }
    .buttons { margin-top: 12px; }
    button { padding: 6px 12px; margin: 2px 4px 2px 0; cursor: pointer; border-radius: 4px; border: 1px solid #ccc; background: #fff; font-size: 13px; }
    button.primary { background: #1677ff; color: #fff; border-color: #1677ff; }
    button.danger { background: #ff4d4f; color: #fff; border-color: #ff4d4f; }
    button.small { padding: 4px 8px; font-size: 12px; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; background: #fff; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; font-size: 13px; }
    th { background: #fafafa; }
    .filters { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 10px; margin-top: 10px; }
    .filters > div { display: flex; flex-direction: column; }
    .filters-actions { margin-top: 8px; display: flex; flex-wrap: wrap; align-items: center; }
    #stats ul { margin: 4px 0 0 20px; padding: 0; }
    #stats li { margin: 2px 0; }
    
    .month-panel { margin: 10px 0 12px; padding: 10px 12px; border: 1px solid #eef2ff; background: #f7f9ff; border-radius: 14px; }
    .month-panel-title { font-size: 14px; font-weight: 700; margin-bottom: 6px; display:flex; align-items:center; gap:8px; }
.month-nav { display: flex; flex-wrap: wrap; align-items: center; gap: 6px; margin-top: 6px; }
    .month-buttons { display: flex; flex-wrap: wrap; gap: 4px; }
    .month-btn { padding: 4px 10px; border-radius: 20px; border: 1px solid #ccc; background: #fff; font-size: 12px; cursor: pointer; }
    .month-btn.active { background: #1677ff; color: #fff; border-color: #1677ff; }
    .month-btn.disabled { background: #eee; color: #999; cursor: not-allowed; }
    .layout-two { display: flex; flex-direction: column; gap: 16px; }
    .chart-container { width: 100%; height: 260px; }

    /* ===== 统计图表 UI ===== */
    .stats-card .muted { color:#8c8c8c; font-size:12px; }
    .stats-head { display:flex; align-items:flex-end; justify-content:space-between; }
    .stats-grid {
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:12px;
      margin-top:12px;
    }
    .stat {
      background: linear-gradient(180deg, #f7f9ff 0%, #ffffff 100%);
      border: 1px solid #eef1ff;
      border-radius: 14px;
      padding: 12px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.03);
      min-height: 74px;
    }
    .stat .label { font-size:12px; color:#8c8c8c; }
    .stat .value { font-size:22px; font-weight:800; margin-top:6px; color:#1f1f1f; }
    .stat .sub { font-size:12px; color:#8c8c8c; margin-top:2px; }
    .chart-surface {
      border: 1px solid #f0f0f0;
      border-radius: 14px;
      padding: 12px;
      background: #fff;
      box-shadow: 0 2px 12px rgba(0,0,0,0.03);
    }
    .chart-title { font-weight:700; font-size:14px; margin-bottom:8px; color:#262626; }
    .chart-pie-wrap { display:flex; flex-direction:column; gap:10px; }
    .legend-list {
      max-height: 180px;
      overflow: auto;
      padding-right: 4px;
    }
    .legend-item {
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      padding: 7px 2px;
      border-bottom: 1px dashed #f0f0f0;
    }
    .legend-item:last-child { border-bottom:none; }
    .legend-swatch {
      width:10px;
      height:10px;
      border-radius: 3px;
      flex: 0 0 auto;
    }
    .legend-name {
      flex: 1 1 auto;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color:#262626;
    }
    .legend-meta {
      flex: 0 0 auto;
      display:flex;
      align-items:baseline;
      gap:6px;
      font-variant-numeric: tabular-nums;
    }
    .legend-count { font-weight:700; color:#262626; }
    .legend-pct { font-size:12px; color:#8c8c8c; }

    @media (max-width: 960px) {
      .stats-grid { grid-template-columns: 1fr; }
      .legend-list { max-height: 220px; }
    }
    @media (max-width: 960px) {
      form, .filters { grid-template-columns: 1fr; }
      .layout-two { grid-template-columns: 1fr; }
    }

/* ===== 表格滑动 + 粘性表头 ===== */
.table-wrap {
  overflow: auto;
  max-height: 62vh;
  border-radius: 8px;
  border: 1px solid #e8e8e8;
  background: #fff;
  -webkit-overflow-scrolling: touch;
  touch-action: pan-x pan-y;
}
.table-wrap table { margin-top: 0; min-width: 980px; }
#recordTable thead th { position: sticky; top: 0; z-index: 2; }
.table-wrap::-webkit-scrollbar { height: 10px; width: 10px; }
.table-wrap::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.18); border-radius: 10px; }
.table-wrap::-webkit-scrollbar-track { background: rgba(0,0,0,0.06); border-radius: 10px; }

/* ===== 分页 ===== */
.pagination {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  justify-content: space-between;
  margin-top: 10px;
  font-size: 13px;
  color: #555;
}
.page-controls { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }
.page-controls button { padding: 4px 10px; border-radius: 999px; }
.page-controls button.active { background: #1677ff; color: #fff; border-color: #1677ff; }
.page-controls button:disabled { cursor: not-allowed; opacity: 0.55; }
.page-controls input[type="number"] { width: 84px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 6px; }
.page-size { width: auto; padding: 4px 8px; border: 1px solid #ddd; border-radius: 8px; background: #fff; }

/* ===== 统一弹窗/提示（替代 alert / confirm） ===== */
.toast-container {
  position: fixed;
  top: 16px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 10000;
  display: flex;
  flex-direction: column;
  gap: 10px;
  pointer-events: none;
}
.toast {
  pointer-events: none;
  background: rgba(17, 17, 17, 0.92);
  color: #fff;
  padding: 10px 14px;
  border-radius: 12px;
  box-shadow: 0 10px 28px rgba(0,0,0,0.18);
  opacity: 0;
  transform: translateY(-8px);
  transition: opacity .2s ease, transform .2s ease;
  min-width: 220px;
  max-width: min(560px, calc(100vw - 40px));
  line-height: 1.4;
}
.toast.show { opacity: 1; transform: translateY(0); }
.toast .title { font-weight: 700; margin-bottom: 2px; font-size: 13px; opacity: .95; }
.toast.info { background: rgba(22, 119, 255, 0.92); }
.toast.success { background: rgba(0, 128, 0, 0.88); }
.toast.warning { background: rgba(250, 140, 22, 0.92); }
.toast.error { background: rgba(255, 77, 79, 0.92); }

.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.35);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10001;
  padding: 18px;
  backdrop-filter: blur(6px);
}
.modal-overlay.show { display: flex; }
.modal {
  width: min(520px, 100%);
  background: #fff;
  border-radius: 16px;
  box-shadow: 0 18px 60px rgba(0,0,0,0.28);
  overflow: hidden;
  transform: translateY(6px) scale(.98);
  opacity: 0;
  transition: transform .18s ease, opacity .18s ease;
}
.modal-overlay.show .modal { transform: translateY(0) scale(1); opacity: 1; }
.modal-header { padding: 14px 16px 8px; display: flex; align-items: center; gap: 10px; }
.modal-title { font-weight: 800; font-size: 16px; }
.modal-body { padding: 0 16px 14px; color: #333; font-size: 14px; line-height: 1.55; }
.modal-footer { padding: 12px 16px 16px; display: flex; justify-content: flex-end; gap: 10px; }
.modal-footer button { border-radius: 10px; padding: 8px 14px; }
.modal-footer .danger { background: #ff4d4f; border-color: #ff4d4f; color: #fff; }
.modal-footer .primary { background: #1677ff; border-color: #1677ff; color: #fff; }
  

/* Ticket form modal */
.ticket-modal-mask{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.45);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10050;
  padding: 18px;
}
.ticket-modal-mask.show{ display:flex; }
.ticket-modal-panel{
  width: min(1100px, 98vw);
  max-height: 90vh;
  overflow: auto;
  background: #fff;
  border-radius: 16px;
  box-shadow: 0 18px 60px rgba(0,0,0,.28);
  padding: 14px 16px 18px;
}
.ticket-modal-header{
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 10px;
}

.ticket-modal-actions{
  position: sticky;
  bottom: 0;
  background: #fff;
  padding-top: 12px;
  margin-top: 12px;
  border-top: 1px solid #eee;
  display: flex;
  gap: 10px;
  justify-content: flex-start;
  flex-wrap: wrap;
}
.ticket-modal-actions button{
  min-width: 96px;
}
.ticket-modal-header h2{
  margin: 0;
  font-size: 18px;
  font-weight: 800;
}
.ticket-modal-close{
  border: none;
  background: transparent;
  font-size: 22px;
  line-height: 1;
  cursor: pointer;
  padding: 6px 10px;
  border-radius: 10px;
}
.ticket-modal-close:hover{ background: rgba(0,0,0,.06); }

  .secondary{ background:#fff; border:1px solid #cfd3d7; color:#1f2d3d; padding:8px 12px; border-radius:6px; cursor:pointer; }
  .secondary:hover{ background:#f6f7f8; }

  /* ===== 写入口令设置 UI ===== */
  .pill{
    display:inline-flex; align-items:center; gap:6px;
    padding: 4px 10px;
    border-radius: 999px;
    font-size: 12px;
    border: 1px solid #d0d7de;
    background: #f6f8fa;
    user-select:none;
  }
  .pill.on{ border-color:#1a7f37; background:#dafbe1; }
  .pill.off{ border-color:#cf222e; background:#ffebe9; }
  .editkey-inline{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .key-form{
    display:grid;
    grid-template-columns: 1fr;
    gap: 12px;
  }
  .key-row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .key-row label{ font-size: 13px; color:#24292f; }
  .key-input{
    flex: 1 1 280px;
    min-width: 240px;
    padding: 10px 12px;
    border: 1px solid #d0d7de;
    border-radius: 8px;
    font-size: 14px;
  }
  .key-help{ font-size: 12px; color:#57606a; line-height: 1.5; }
  .key-actions{ display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; }
  .btn-danger{ background:#cf222e; color:#fff; border:1px solid #b62324; }
  .btn-ghost{ background:#fff; }



  /* ===== 系统设置（更像设置面板） ===== */
  #settingsCard .settings-group{ display:flex; flex-direction:column; gap:12px; }
  #settingsCard .settings-item{
    border:1px solid #eee;
    border-radius: 12px;
    padding: 12px 14px;
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap: 14px;
    background:#fff;
  }
  #settingsCard .settings-main{ min-width: 0; }
  #settingsCard .settings-title{ font-weight: 800; font-size: 15px; margin-bottom: 6px; }
  #settingsCard .settings-desc{ color:#555; font-size: 13px; line-height: 1.5; margin-bottom: 6px; }
  #settingsCard .settings-meta{ color:#666; font-size: 12px; display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  #settingsCard .settings-actions{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
  #settingsCard .settings-sep{ opacity:.55; }

</style>
</head>
<body>
<h1>工单记录系统（年度多维度增强版）</h1>
<div class="card">
<div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;">
<h2 style="margin:0;">工单操作</h2>
<div style="display:flex;gap:10px;flex-wrap:wrap;">
<button class="primary" onclick="openTicketModal(true)" type="button">新增工单</button>
</div>
</div>
<div class="muted" style="margin-top:8px;">点击“新增工单”在弹窗中录入/编辑；保存后弹窗保持打开，可连续录入。</div>
</div>




<div class="card" id="settingsCard">
  <h2>系统设置</h2>

  <div class="settings-group">
    <div class="settings-item">
      <div class="settings-main">
        <div class="settings-title">写入权限</div>
        <div class="settings-desc">读取（GET）公开；新增/编辑/删除/覆盖导入需要共享写入口令。口令仅保存在当前浏览器。</div>
        <div class="settings-meta">
          状态：<span id="editKeyStatus" class="pill off">未设置</span>
          <span class="settings-sep">|</span>
          上次设置：<span id="editKeySetAt">-</span>
        </div>
      </div>

      <div class="settings-actions">
        <button type="button" class="secondary" onclick="openKeyModal()">管理口令</button>
        <button type="button" class="btn-ghost" onclick="testEditKey()">测试口令</button>
      </div>
    </div>
  </div>
</div>

<!-- 筛选 & 月份视图 & 导出 / 备份操作 -->
<div class="card">
<h2>查询 / 导出与备份</h2>
<!-- 常规模糊筛选 -->
<div style="margin-top:12px;">
<h3>高级筛选</h3>
<div class="filters">
<div>
<label>开始日期：</label>
<input id="filterFrom" type="date"/>
</div>
<div>
<label>结束日期：</label>
<input id="filterTo" type="date"/>
</div>
<div>
<label>类型：</label>
<select id="filterType">
<option value="">全部类型</option>
<option>日常故障</option>
<option>office365套装故障</option>
<option>OA等业务平台故障</option>
<option>电脑维修报修</option>
<option>电脑重置安装</option>
<option>密码问题</option>
<option>打印机问题</option>
<option>VPN/网络问题</option>
<option>会议问题</option>
<option>用户咨询</option>
</select>
</div>
<div>
<label>关键字（问题/部门/姓名等）：</label>
<input id="filterKeyword" placeholder="输入关键字..." type="text"/>
</div>
</div>
<div class="filters-actions">
<button class="primary" onclick="renderTable()">应用筛选</button>
<button onclick="clearFilters()">清空筛选</button>
<button class="secondary" id="trashToggleBtn" type="button" onclick="toggleTrashView()">回收站</button>
<span id="viewModePill" class="pill" style="margin-left:6px;">工单</span>
</div>
</div>
<!-- 导出 / 备份操作 -->
<div style="margin-top:12px;">
<h3>导出 / 备份操作</h3>
<div class="buttons">
<button onclick="exportExcelCurrent()">导出当前筛选为 Excel（单 Sheet）</button>
<button onclick="exportExcelByMonth()">按月份分 Sheet 导出 Excel</button>
<button onclick="backupData()">导出 JSON 备份</button>
<label style="font-size:13px; margin-left:4px;">
          载入备份：
          <input accept="application/json" onchange="loadBackup(event)" type="file"/>
</label>
<button onclick="archiveByMonthJSON()">按月份导出 JSON（多文件）</button>
<button onclick="exportYearZip()">打包年度 ZIP（全部月份 JSON）</button>
</div>
<!-- 手动目录备份（点击时选择目录并导出 JSON） -->
<div style="margin-top:8px;font-size:13px;">
<button onclick="manualBackup()">导出到本地目录</button>
</div>
</div>
<div id="stats" style="margin-top:10px;font-size:14px;"></div>
</div>
<!-- 工单列表 + 图表区域 -->
<div class="layout-two">
<div class="card">
<h2>工单列表</h2>
<div aria-label="月份视图" class="month-panel">
<div class="month-panel-title">月份视图</div>
<div class="month-nav">
<div>
<label for="yearSelect">年份：</label>
<select id="yearSelect" onchange="onYearChange()">
<option value="">全部年份</option>
</select>
</div>
<div class="month-buttons" id="monthButtons"></div>
</div>
</div>
<div class="table-wrap" id="tableWrap">
<table id="recordTable">
<thead>
<tr>
<th>日期</th>
<th>问题</th>
<th>部门</th>
<th>姓名</th>
<th>处理方法</th>
<th>备注</th>
<th>类型</th>
<th>操作</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
<div class="pagination" id="pagination"></div>
</div>
<div class="card stats-card">
<div class="stats-head">
<div>
<h2 style="margin-bottom:4px;">统计图表</h2>
<div class="muted">基于当前筛选 + 年份/月份视图</div>
</div>
</div>
<!-- 概览 -->
<div class="stats-grid" id="statsCards"></div>
<!-- 类型饼图 + 自定义图例 -->
<div class="chart-surface" style="margin-top:14px;">
<div class="chart-title">当前视图 - 故障类型分布</div>
<div class="chart-pie-wrap">
<div class="chart-container" style="height:240px;">
<canvas id="typePieChart"></canvas>
</div>
<div aria-label="类型图例" class="legend-list" id="typeLegend"></div>
</div>
</div>
<!-- 月份柱状图 -->
<div class="chart-surface" style="margin-top:14px;">
<div class="chart-title">当前视图 - 各月份工单数量</div>
<div class="chart-container" style="height:240px;">
<canvas id="monthBarChart"></canvas>
</div>
</div>
</div>
</div>

<div class="ticket-modal-mask" id="ticketModal" onclick="onTicketModalMaskClick(event)">
<div aria-labelledby="ticketModalTitle" aria-modal="true" class="ticket-modal-panel" role="dialog">
<div class="ticket-modal-header">
<h2 id="ticketModalTitle">新增 / 编辑工单</h2>
<button class="ticket-modal-close" onclick="closeTicketModal()" type="button">×</button>
</div>
<div class="ticket-modal-body"><form id="ticketForm" onsubmit="event.preventDefault(); addOrUpdateRecord();">
<div>
<label>日期：</label>
<input id="date" required="" type="date"/>
</div>
<div>
<label>问题：</label>
<input id="issue" required="" type="text"/>
</div>
<div>
<label>部门：</label>
<input id="department" type="text"/>
</div>
<div>
<label>姓名：</label>
<input id="name" type="text"/>
</div>
<div>
<label>处理方法：</label>
<textarea id="solution"></textarea>
</div>
<div>
<label>备注：</label>
<textarea id="remarks"></textarea>
</div>
<div>
<label>类型：</label>
<select id="type">
<option>日常故障</option>
<option>office365套装故障</option>
<option>OA等业务平台故障</option>
<option>电脑维修报修</option>
<option>电脑重置安装</option>
<option>密码问题</option>
<option>打印机问题</option>
<option>VPN/网络问题</option>
<option>会议问题</option>
<option>用户咨询</option>
</select>
</div>

<div class="ticket-modal-actions">
  <button id="submitBtn" type="submit" class="primary">确定</button>
  <button type="button" onclick="resetForm(true)">清空表单</button>
  <button type="button" onclick="closeTicketModal()">关闭</button>
</div>
</form></div>
</div>

<!-- 写入口令设置（更正式 UI） -->
<div class="ticket-modal-mask" id="keyModal" onclick="onKeyModalMaskClick(event)">
  <div class="ticket-modal-panel" role="dialog" aria-modal="true" aria-labelledby="keyModalTitle" style="width:min(640px,96vw);">
    <div class="ticket-modal-header">
      <div style="font-weight:700;font-size:18px;" id="keyModalTitle">写入口令设置</div>
      <button type="button" class="ticket-modal-close" onclick="closeKeyModal()">×</button>
    </div>

    <div class="key-form">
      <div class="key-row">
        <label for="editKeyInput"><b>写入口令</b></label>
        <input id="editKeyInput" class="key-input" type="password" autocomplete="off" placeholder="输入共享口令（用于新增/编辑/删除/导入）" />
      </div>

      <div class="key-row">
        <label><input id="editKeyShow" type="checkbox" onchange="toggleEditKeyVisibility()" /> 显示口令</label>
        <span id="editKeyStatus2" class="pill off">未设置</span>
      </div>

      <div class="key-help">
        <div>• 上次设置：<b><span id="editKeySetAt2">-</span></b></div>
        <div>• 读取（GET）公开；写入（POST/PUT/DELETE/导入覆盖云端）需要口令。</div>
        <div>• 口令仅保存在<b>当前浏览器</b>的 localStorage，不会上传到云端。</div>
        <div>• 如果口令输入错误，写操作会返回 401，并提示你重新设置。</div>
      </div>

      <div class="key-actions">
        <button type="button" class="btn-ghost" onclick="closeKeyModal()">关闭</button>
        <button type="button" class="btn-danger" onclick="clearEditKeyFromUI()">清除</button>
        <button type="button" class="btn-ghost" onclick="testEditKey()">测试</button>
        <button type="button" class="primary" onclick="saveEditKeyFromUI()">保存</button>
      </div>
    </div>
  </div>
</div>

</div>
<script>
    let records = [];
    let editingId = null;
    let editingUpdatedAt = ""; // optimistic concurrency token from server
    let nextId = 1;

    // ===== 视图模式：工单 / 回收站 =====
    const VIEW_MODE_STORAGE = "ticket_view_mode";
    let viewMode = "active"; // 'active' | 'trash'

    function loadViewMode() {
      try {
        const v = (localStorage.getItem(VIEW_MODE_STORAGE) || "active").toLowerCase();
        viewMode = (v === "trash") ? "trash" : "active";
      } catch {
        viewMode = "active";
      }
    }
    function saveViewMode() {
      try { localStorage.setItem(VIEW_MODE_STORAGE, viewMode); } catch {}
    }
    function updateViewModeUI() {
      const btn = document.getElementById("trashToggleBtn");
      const pill = document.getElementById("viewModePill");
      if (btn) btn.textContent = viewMode === "trash" ? "返回工单" : "回收站";
      if (pill) {
        pill.textContent = viewMode === "trash" ? "回收站" : "工单";
        pill.classList.remove("on", "off");
        pill.classList.add(viewMode === "trash" ? "off" : "on");
      }
    }
    async function toggleTrashView() {
      viewMode = viewMode === "trash" ? "active" : "trash";
      saveViewMode();
      updateViewModeUI();
      await reloadAndRender({ showLoadedToast: true });
    }


    // ===== 写入口令（仅保护写操作）=====
    const EDIT_KEY_STORAGE = "ticket_edit_key";

    function getEditKey() {
      try { return localStorage.getItem(EDIT_KEY_STORAGE) || ""; } catch { return ""; }
    }
    function setEditKey(key) {
      try { localStorage.setItem(EDIT_KEY_STORAGE, String(key || "")); } catch {}
    }
    function clearEditKey() {
      try { localStorage.removeItem(EDIT_KEY_STORAGE); } catch {}
    }
    

    const EDIT_KEY_SET_AT_STORAGE = "ticket_edit_key_set_at";

    function getEditKeySetAt() {
      try { return localStorage.getItem(EDIT_KEY_SET_AT_STORAGE) || ""; } catch { return ""; }
    }
    function setEditKeySetAtNow() {
      try { localStorage.setItem(EDIT_KEY_SET_AT_STORAGE, new Date().toISOString()); } catch {}
    }
    function clearEditKeySetAt() {
      try { localStorage.removeItem(EDIT_KEY_SET_AT_STORAGE); } catch {}
    }

    function formatISOToLocal(iso) {
      if (!iso) return "-";
      const d = new Date(iso);
      if (isNaN(d.getTime())) return iso;
      const pad = (n) => String(n).padStart(2, "0");
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }

    let __editKeyWaiters = [];
    function resolveEditKeyWaiters(value) {
      try {
        __editKeyWaiters.forEach((r) => r(value));
      } finally {
        __editKeyWaiters = [];
      }
    }

    function updateEditKeyStatus() {
      const key = getEditKey();
      const on = !!key;
      const setAt = formatISOToLocal(getEditKeySetAt());

      const applyPill = (el) => {
        if (!el) return;
        el.classList.remove("on", "off");
        el.classList.add(on ? "on" : "off");
        el.textContent = on ? "已设置" : "未设置";
      };

      applyPill(document.getElementById("editKeyStatus"));
      applyPill(document.getElementById("editKeyStatus2"));

      const el1 = document.getElementById("editKeySetAt");
      const el2 = document.getElementById("editKeySetAt2");
      if (el1) el1.textContent = on ? setAt : "-";
      if (el2) el2.textContent = on ? setAt : "-";
    }

    function openKeyModal() {
      const modal = document.getElementById("keyModal");
      if (!modal) return;
      modal.classList.add("show");
      const input = document.getElementById("editKeyInput");
      if (input) input.value = getEditKey() || "";
      const show = document.getElementById("editKeyShow");
      if (show) show.checked = false;
      if (input) input.type = "password";
      updateEditKeyStatus();
      if (input) input.focus();
    }

    function closeKeyModal() {
      const modal = document.getElementById("keyModal");
      if (!modal) return;
      modal.classList.remove("show");
      // 如果有等待 ensureEditKey 的调用，关闭视为放弃
      resolveEditKeyWaiters(getEditKey() || "");
    }

    function onKeyModalMaskClick(e) {
      if (e.target && e.target.id === "keyModal") closeKeyModal();
    }

    function toggleEditKeyVisibility() {
      const input = document.getElementById("editKeyInput");
      const show = document.getElementById("editKeyShow");
      if (!input || !show) return;
      input.type = show.checked ? "text" : "password";
    }

    function saveEditKeyFromUI() {
      const input = document.getElementById("editKeyInput");
      const key = (input ? input.value : "").trim();
      if (!key) {
        clearEditKey();
        clearEditKeySetAt();
        updateEditKeyStatus();
        resolveEditKeyWaiters("");
        if (typeof showToast === "function") showToast("已清除写入口令。", "success");
        return;
      }
      setEditKey(key);
      setEditKeySetAtNow();
      updateEditKeyStatus();
      resolveEditKeyWaiters(key);
      if (typeof showToast === "function") showToast("写入口令已保存（仅当前浏览器）。", "success");
    }

    function clearEditKeyFromUI() {
      clearEditKey();
      clearEditKeySetAt();
      const input = document.getElementById("editKeyInput");
      if (input) input.value = "";
      updateEditKeyStatus();
      resolveEditKeyWaiters("");
      if (typeof showToast === "function") showToast("已清除写入口令。", "success");
    }

    async function ensureEditKey() {
      const existing = getEditKey();
      if (existing) return existing;

      // 弹出设置窗口，并等待用户保存/关闭
      openKeyModal();
      if (typeof showToast === "function") showToast("请先设置写入口令后再执行写操作。", "warning");

      return await new Promise((resolve) => {
        __editKeyWaiters.push(resolve);
      });
    }

    async function testEditKey() {
      const key = getEditKey();
      if (!key) {
        openKeyModal();
        if (typeof showToast === "function") showToast("请先设置写入口令，再进行测试。", "warning");
        return;
      }
      try {
        const res = await fetch("/api/auth-test", {
          method: "GET",
          headers: { "X-EDIT-KEY": key },
          cache: "no-store",
        });
        if (res.ok) {
          if (typeof showToast === "function") showToast("口令测试通过 ✅", "success");
        } else if (res.status === 401) {
          clearEditKey();
          clearEditKeySetAt();
          updateEditKeyStatus();
          if (typeof showToast === "function") showToast("口令错误（401），请重新设置。", "error");
          openKeyModal();
        } else if (res.status === 500) {
          if (typeof showToast === "function") showToast("服务端未配置 EDIT_KEY（500）。", "error");
        } else {
          if (typeof showToast === "function") showToast(`测试失败：${res.status}`, "error");
        }
      } catch (e) {
        if (typeof showToast === "function") showToast("无法连接服务端进行测试。", "error");
      }
    }

// ⭐ 本地存储：从 localStorage 恢复 records
    function loadFromLocal() {
      try {
        const saved = localStorage.getItem("ticket_records");
        if (saved) {
          const data = JSON.parse(saved);
          if (Array.isArray(data)) {
            records = normalizeRecords(data);
            const maxId = records.reduce((max, r) => {
              const v = Number(r.id);
              return Number.isFinite(v) ? Math.max(max, v) : max;
            }, 0);
            nextId = maxId + 1;
          }
        }
      } catch (e) {
        console.error("从本地恢复数据失败：", e);
      }
    }

    // ===== 云端存储（Cloudflare Pages Functions + D1）=====
    async function loadFromServer() {
      const res = await fetch("/api/tickets", { cache: "no-store" });
      if (!res.ok) throw new Error(`load failed: ${res.status}`);
      const data = await res.json();
      records = normalizeRecords(Array.isArray(data) ? data : []);
      const maxId = records.reduce((max, r) => {
        const v = Number(r.id);
        return Number.isFinite(v) ? Math.max(max, v) : max;
      }, 0);
      nextId = maxId + 1;
    }

    async function reloadAndRender({ showLoadedToast = false } = {}) {
      await loadFromServer();
      saveToLocal(); // 缓存一份到本地，作为兜底
      refreshYearOptions();
      renderTable();
      if (showLoadedToast) {
        showToast(`已从云端加载 ${records.length} 条${viewMode === "trash" ? "回收站记录" : "工单"}`, "success");
      }
    }


    async function authedFetch(url, options = {}) {
      const method = String(options.method || "GET").toUpperCase();
      const needAuth = ["POST", "PUT", "DELETE", "PATCH"].includes(method);
      if (!needAuth) return fetch(url, options);

      const key = await ensureEditKey();
      const headers = new Headers(options.headers || {});
      if (key) headers.set("X-EDIT-KEY", key);

      const res = await fetch(url, { ...options, headers });

      if (res.status === 401) {
        clearEditKey();
        updateEditKeyStatus();
        if (typeof showToast === "function") showToast("写入口令错误，请重新输入。", "error");
      } else if (res.status === 500) {
        if (typeof showToast === "function") showToast("服务端未配置 EDIT_KEY。", "error");
      }
      return res;
    }
    

    

    // ===== 新增/编辑弹窗（Modal）=====
    function openTicketModal(reset = true) {
      const mask = document.getElementById("ticketModal");
      if (!mask) return;
      mask.classList.add("show");
      if (reset) {
        resetForm(true);
      }
      // 聚焦日期输入，便于连续录入
      setTimeout(() => {
        const el = document.getElementById("date");
        if (el) el.focus();
      }, 0);
    }

    function closeTicketModal() {
      const mask = document.getElementById("ticketModal");
      if (!mask) return;
      mask.classList.remove("show");
    }

    function onTicketModalMaskClick(e) {
      if (e && e.target && e.target.id === "ticketModal") closeTicketModal();
    }

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeTicketModal();
    });

// 统一数据结构：内部一律使用 {id,date,issue,department,name,solution,remarks,type}
    function normalizeRecord(r, fallbackId) {
      const obj = (r && typeof r === "object") ? r : {};
      return {
        id: (() => { const v = Number(obj.id ?? obj.ID ?? obj.Id ?? fallbackId); return Number.isFinite(v) ? v : fallbackId; })(),
        date: obj.date ?? obj.日期 ?? obj.time ?? obj.createdAt ?? "",
        issue: obj.issue ?? obj.问题 ?? obj.question ?? obj.title ?? obj.subject ?? "",
        department: obj.department ?? obj.dept ?? obj.部门 ?? obj.departmentName ?? "",
        name: obj.name ?? obj.owner ?? obj.person ?? obj.姓名 ?? obj.handler ?? "",
        solution: obj.solution ?? obj.method ?? obj.处理方法 ?? obj.fix ?? "",
        remarks: obj.remarks ?? obj.remark ?? obj.备注 ?? obj.note ?? "",
        type: obj.type ?? obj.类型 ?? obj.category ?? "",
        updated_at: obj.updated_at ?? obj.updatedAt ?? "",
        is_deleted: Number(obj.is_deleted ?? obj.isDeleted ?? 0) ? 1 : 0,
        deleted_at: obj.deleted_at ?? obj.deletedAt ?? ""
      };
    }

    function normalizeRecords(arr) {
      if (!Array.isArray(arr)) return [];
      return arr.map((r, idx) => normalizeRecord(r, idx + 1));
    }
let activeYear = ""; // 当前选择的年份（字符串，如 "2025"）
    let activeMonth = ""; // 当前选择的月份（字符串，"01" ~ "12"）

    let typePieChart = null;
    let monthBarChart = null;


// ===== 分页配置（每页最多 100 条）=====
const PAGE_SIZE_MAX = 100;
let pageSize = 100;     // 可选更小，但上限 100
let currentPage = 1;

function clamp(num, min, max) {
  return Math.max(min, Math.min(max, num));
}

// ===== 统一提示/弹窗（更好看的 UI，替代 alert / confirm）=====
function showToast(message, variant = "info", title = "") {
  const container = document.getElementById("toastContainer");
  if (!container) {
    // 兜底：容器不存在时仍然不阻断主流程
    console.log(`[${variant}] ${title ? title + " - " : ""}${message}`);
    return;
  }
  const toast = document.createElement("div");
  toast.className = `toast ${variant}`;
  toast.innerHTML = `${title ? `<div class="title">${escapeHtml(title)}</div>` : ""}<div>${escapeHtml(message)}</div>`;
  container.appendChild(toast);

  // 强制触发一次 layout，保证动画生效
  requestAnimationFrame(() => toast.classList.add("show"));

  setTimeout(() => {
    toast.classList.remove("show");
    setTimeout(() => toast.remove(), 220);
  }, 2200);
}

function escapeHtml(str) {
  return String(str)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}


function showModal({ title = "提示", message = "", okText = "确定", variant = "primary" } = {}) {
  const overlay = document.getElementById("modalOverlay");
  const titleEl = document.getElementById("modalTitle");
  const bodyEl = document.getElementById("modalBody");
  const footerEl = document.getElementById("modalFooter");
  if (!overlay || !titleEl || !bodyEl || !footerEl) {
    // 兜底
    alert(message);
    return Promise.resolve();
  }

  overlay.setAttribute("aria-hidden", "false");
  overlay.classList.add("show");
  titleEl.textContent = title;
  bodyEl.textContent = message;
  footerEl.innerHTML = "";

  const okBtn = document.createElement("button");
  okBtn.className = variant === "danger" ? "danger" : "primary";
  okBtn.textContent = okText;

  return new Promise(resolve => {
    function close() {
      overlay.classList.remove("show");
      overlay.setAttribute("aria-hidden", "true");
      overlay.onclick = null;
      window.removeEventListener("keydown", onKeyDown);
      resolve();
    }

    function onKeyDown(e) {
      if (e.key === "Escape") close();
    }

    okBtn.onclick = close;
    overlay.onclick = (e) => { if (e.target === overlay) close(); };
    window.addEventListener("keydown", onKeyDown);

    footerEl.appendChild(okBtn);
    okBtn.focus({ preventScroll: true });
  });
}function showConfirm({ title = "确认操作", message = "", confirmText = "确定", cancelText = "取消", danger = false } = {}) {
  const overlay = document.getElementById("modalOverlay");
  const titleEl = document.getElementById("modalTitle");
  const bodyEl = document.getElementById("modalBody");
  const footerEl = document.getElementById("modalFooter");
  if (!overlay || !titleEl || !bodyEl || !footerEl) {
    return Promise.resolve(confirm(message));
  }

  overlay.setAttribute("aria-hidden", "false");
  overlay.classList.add("show");
  titleEl.textContent = title;
  bodyEl.textContent = message;
  footerEl.innerHTML = "";

  const cancelBtn = document.createElement("button");
  cancelBtn.textContent = cancelText;

  const okBtn = document.createElement("button");
  okBtn.className = danger ? "danger" : "primary";
  okBtn.textContent = confirmText;

  return new Promise(resolve => {
    function close(result) {
      overlay.classList.remove("show");
      overlay.setAttribute("aria-hidden", "true");
      overlay.onclick = null;
      window.removeEventListener("keydown", onKeyDown);
      resolve(result);
    }

    function onKeyDown(e) {
      if (e.key === "Escape") close(false);
    }

    cancelBtn.onclick = () => close(false);
    okBtn.onclick = () => close(true);
    overlay.onclick = (e) => { if (e.target === overlay) close(false); };
    window.addEventListener("keydown", onKeyDown);

    footerEl.appendChild(cancelBtn);
    footerEl.appendChild(okBtn);
    okBtn.focus({ preventScroll: true });
  });
}

    // ⭐ 本地存储：保存 records 到 localStorage
    function saveToLocal() {
      try {
        localStorage.setItem("ticket_records", JSON.stringify(records));
      } catch (e) {
        console.error("保存到本地失败：", e);
      }
    }


    function saveViewState() {
      try {
        localStorage.setItem("ticket_view_year", activeYear || "");
        localStorage.setItem("ticket_view_month", activeMonth || "");
      } catch (e) {
        // ignore
      }
    }

    function loadViewState() {
      try {
        activeYear = localStorage.getItem("ticket_view_year") || "";
        activeMonth = localStorage.getItem("ticket_view_month") || "";
      } catch (e) {
        activeYear = "";
        activeMonth = "";
      }
    }


    // ⭐ 本地存储：从 localStorage 恢复 records
    function loadFromLocal() {
      try {
        const saved = localStorage.getItem("ticket_records");
        if (saved) {
          const data = JSON.parse(saved);
          if (Array.isArray(data)) {
            records = normalizeRecords(data);
            const maxId = records.reduce((max, r) => {
              const v = Number(r.id);
              return Number.isFinite(v) ? Math.max(max, v) : max;
            }, 0);
            nextId = maxId + 1;
          }
        }
      } catch (e) {
        console.error("从本地恢复数据失败：", e);
      }
    }

    // ===== 云端存储（Cloudflare Pages Functions + D1）=====
    async function loadFromServer() {
      const url = viewMode === "trash" ? "/api/tickets?trash=1" : "/api/tickets";
      const res = await authedFetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`load failed: ${res.status}`);
      const data = await res.json();
      records = normalizeRecords(Array.isArray(data) ? data : []);
      const maxId = records.reduce((max, r) => {
        const v = Number(r.id);
        return Number.isFinite(v) ? Math.max(max, v) : max;
      }, 0);
      nextId = maxId + 1;
    }

    async function reloadAndRender({ showLoadedToast = false } = {}) {
      await loadFromServer();
      saveToLocal(); // 缓存一份到本地，作为兜底
      refreshYearOptions();
      renderTable();
      if (showLoadedToast) {
        showToast(`已从云端加载 ${records.length} 条工单`, "success");
      }
    }

async function addOrUpdateRecord() {
  const date = document.getElementById("date").value;
  const issue = document.getElementById("issue").value.trim();
  const department = document.getElementById("department").value.trim();
  const name = document.getElementById("name").value.trim();
  const solution = document.getElementById("solution").value.trim();
  const remarks = document.getElementById("remarks").value.trim();
  const type = document.getElementById("type").value;

  if (!date || !issue) {
    showToast("请至少填写日期和问题！", "warning");
    return;
  }

  const payload = { date, issue, department, name, solution, remarks, type };

  const btn = document.getElementById("submitBtn");
  const oldText = btn ? btn.innerText : "";
  if (btn) {
    btn.disabled = true;
    btn.innerText = editingId === null ? "保存中..." : "保存中...";
  }

  try {
    if (editingId === null) {
      const res = await authedFetch("/api/tickets", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if (!res.ok) throw new Error(`create failed: ${res.status}`);
    } else {
      // 带上 updated_at 做乐观并发控制
      let res = await authedFetch(`/api/tickets/${editingId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ...payload, id: editingId, updated_at: editingUpdatedAt })
      });

      // 冲突：别人已更新 -> 409
      if (res.status === 409) {
        let info = null;
        try { info = await res.json(); } catch {}
        const latest = info && info.current ? normalizeRecord(info.current, editingId) : null;

        const overwrite = await showConfirm({
          title: "编辑冲突",
          message: "该工单已被其他人修改。\n\n选择【覆盖保存】将以你当前内容覆盖对方修改；选择【加载最新】将刷新为最新版本，然后你可重新编辑。",
          confirmText: "覆盖保存",
          cancelText: "加载最新",
          danger: true
        });

        if (!overwrite) {
          await reloadAndRender({ showLoadedToast: false });
          if (latest) {
            fillFormFromRecord(latest);
          }
          showToast("已加载最新版本，请确认后重新编辑保存。", "info");
          return;
        }

        // 覆盖保存（force）
        res = await authedFetch(`/api/tickets/${editingId}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ ...payload, id: editingId, force: true })
        });
      }

      if (!res.ok) throw new Error(`update failed: ${res.status}`);

      editingId = null;
      editingUpdatedAt = "";
      document.getElementById("submitBtn").innerText = "确定";
    }

    resetForm(false);
    await reloadAndRender();
    showToast("已保存到云端。", "success");
  } catch (e) {
    if (isNoKeyError(e)) return;
    console.error(e);
    showToast("保存失败：请检查网络或后端是否正常。", "error");
  } finally {
    if (btn) {
      btn.disabled = false;
      btn.innerText = editingId === null ? "确定" : (oldText || "保存修改");
    }
  }
}

function resetForm(resetEditing = true) {
  document.getElementById("ticketForm").reset();
  if (resetEditing) {
    editingId = null;
    editingUpdatedAt = "";
    document.getElementById("submitBtn").innerText = "确定";
  }
}

function fillFormFromRecord(record) {
  if (!record) return;
  editingId = record.id;
  editingUpdatedAt = record.updated_at || "";
  document.getElementById("date").value = record.date || "";
  document.getElementById("issue").value = record.issue || "";
  document.getElementById("department").value = record.department || "";
  document.getElementById("name").value = record.name || "";
  document.getElementById("solution").value = record.solution || "";
  document.getElementById("remarks").value = record.remarks || "";
  document.getElementById("type").value = record.type || "日常故障";
  document.getElementById("submitBtn").innerText = "保存修改";
}

    function editRecord(id) {
      const record = records.find(r => r.id === id);
      if (!record) return;
      editingId = id;
      editingUpdatedAt = record.updated_at || "";
      document.getElementById("date").value = record.date || "";
      document.getElementById("issue").value = record.issue || "";
      document.getElementById("department").value = record.department || "";
      document.getElementById("name").value = record.name || "";
      document.getElementById("solution").value = record.solution || "";
      document.getElementById("remarks").value = record.remarks || "";
      document.getElementById("type").value = record.type || "日常故障";
      document.getElementById("submitBtn").innerText = "保存修改";
      openTicketModal(false);
    }


    

async function deleteRecord(id) {
  const ok = await showConfirm({
    title: "确认删除",
    message: "确认将这条工单移入回收站吗？\n\n你可以在【回收站】中恢复。",
    confirmText: "移入回收站",
    cancelText: "取消",
    danger: true
  });
  if (!ok) return;

  try {
    const res = await authedFetch(`/api/tickets/${id}`, { method: "DELETE" });
    if (!res.ok) throw new Error(`delete failed: ${res.status}`);

    if (editingId === id) resetForm();
    await reloadAndRender();
    showToast("已移入回收站。", "success");
  } catch (e) {
    if (isNoKeyError(e)) return;
    console.error(e);
    showToast("删除失败：请检查网络或后端是否正常。", "error");
  }
}

async function restoreRecord(id) {
  const ok = await showConfirm({
    title: "恢复工单",
    message: "确认从回收站恢复这条工单吗？",
    confirmText: "恢复",
    cancelText: "取消",
    danger: false
  });
  if (!ok) return;
  try {
    const res = await authedFetch(`/api/tickets/${id}/restore`, { method: "PUT" });
    if (!res.ok) throw new Error(`restore failed: ${res.status}`);
    await reloadAndRender();
    showToast("已恢复该工单。", "success");
  } catch (e) {
    if (isNoKeyError(e)) return;
    console.error(e);
    showToast("恢复失败：请检查网络或后端是否正常。", "error");
  }
}

async function hardDeleteRecord(id) {
  const ok = await showConfirm({
    title: "彻底删除",
    message: "确认【彻底删除】这条记录吗？\n\n此操作不可恢复。",
    confirmText: "彻底删除",
    cancelText: "取消",
    danger: true
  });
  if (!ok) return;
  try {
    const res = await authedFetch(`/api/tickets/${id}/hard`, { method: "DELETE" });
    if (!res.ok) throw new Error(`hard delete failed: ${res.status}`);
    await reloadAndRender();
    showToast("已彻底删除。", "success");
  } catch (e) {
    if (isNoKeyError(e)) return;
    console.error(e);
    showToast("彻底删除失败：请检查网络或后端是否正常。", "error");
  }
}

    function clearFilters() {
      document.getElementById("filterFrom").value = "";
      document.getElementById("filterTo").value = "";
      document.getElementById("filterType").value = "";
      document.getElementById("filterKeyword").value = "";
      // 保留月份视图状态，仅清空高级筛选
      renderTable();
}

    function getFilteredRecords() {
      const from = document.getElementById("filterFrom").value;
      const to = document.getElementById("filterTo").value;
      const type = document.getElementById("filterType").value;
      const keyword = document.getElementById("filterKeyword").value.trim().toLowerCase();

      return records.filter(r => {
        if (activeYear && r.date.slice(0, 4) !== activeYear) return false;
        if (activeMonth && r.date.slice(5, 7) !== activeMonth) return false;
        if (from && r.date < from) return false;
        if (to && r.date > to) return false;
        if (type && r.type !== type) return false;
        if (keyword) {
          const combined = `${r.issue} ${r.department} ${r.name} ${r.solution} ${r.remarks}`.toLowerCase();
          if (!combined.includes(keyword)) return false;
        }
        return true;
      });
    }

    
function renderTable({ resetPage = true } = {}) {
  const tbody = document.getElementById("recordTable").querySelector("tbody");
  tbody.innerHTML = "";

  const filtered = getFilteredRecords();

  // 分页计算
  const totalItems = filtered.length;
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize));
  if (resetPage) currentPage = 1;
  currentPage = clamp(currentPage, 1, totalPages);

  const startIndex = (currentPage - 1) * pageSize;
  const endIndex = startIndex + pageSize;
  const pageRecords = filtered.slice(startIndex, endIndex);

  if (pageRecords.length === 0) {
    const row = tbody.insertRow();
    const cell = row.insertCell(0);
    cell.colSpan = 8;
    cell.style.textAlign = "center";
    cell.style.color = "#999";
    cell.style.padding = "14px 8px";
    cell.innerText = viewMode === "trash" ? "回收站暂无记录" : "暂无工单记录";
  } else {
    pageRecords.forEach(r => {
      const row = tbody.insertRow();
      row.insertCell(0).innerText = r.date;
      row.insertCell(1).innerText = r.issue;
      row.insertCell(2).innerText = r.department;
      row.insertCell(3).innerText = r.name;
      row.insertCell(4).innerText = r.solution;
      row.insertCell(5).innerText = r.remarks;
      row.insertCell(6).innerText = r.type;
      const actionCell = row.insertCell(7);

      if (viewMode === "trash") {
        const restoreBtn = document.createElement("button");
        restoreBtn.innerText = "恢复";
        restoreBtn.className = "small";
        restoreBtn.onclick = () => restoreRecord(r.id);

        const hardBtn = document.createElement("button");
        hardBtn.innerText = "彻底删除";
        hardBtn.className = "small danger";
        hardBtn.onclick = () => hardDeleteRecord(r.id);

        actionCell.appendChild(restoreBtn);
        actionCell.appendChild(hardBtn);
      } else {
        const editBtn = document.createElement("button");
        editBtn.innerText = "编辑";
        editBtn.className = "small";
        editBtn.onclick = () => editRecord(r.id);

        const delBtn = document.createElement("button");
        delBtn.innerText = "删除";
        delBtn.className = "small danger";
        delBtn.onclick = () => deleteRecord(r.id);

        actionCell.appendChild(editBtn);
        actionCell.appendChild(delBtn);
      }
    });
  }

  updateStatsAndCharts(filtered); // 统计/图表基于“当前视图（全部筛选结果）”
  refreshMonthButtons();
  renderPagination(totalItems);
}

function renderPagination(totalItems) {
  const el = document.getElementById("pagination");
  if (!el) return;

  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize));
  currentPage = clamp(currentPage, 1, totalPages);

  el.innerHTML = "";

  const info = document.createElement("div");
  info.className = "page-info";
  const start = totalItems === 0 ? 0 : (currentPage - 1) * pageSize + 1;
  const end = Math.min(totalItems, currentPage * pageSize);
  info.textContent = `显示 ${start}-${end} / ${totalItems} 条`;

  const controls = document.createElement("div");
  controls.className = "page-controls";

  // 每页条数（上限 100）
  const sizeLabel = document.createElement("span");
  sizeLabel.textContent = "每页：";
  const sizeSelect = document.createElement("select");
  sizeSelect.className = "page-size";
  [20, 50, 100].forEach(n => {
    const opt = document.createElement("option");
    opt.value = String(n);
    opt.textContent = `${n} 条`;
    sizeSelect.appendChild(opt);
  });
  sizeSelect.value = String(pageSize);
  sizeSelect.onchange = () => {
    pageSize = Math.min(Number(sizeSelect.value) || 100, PAGE_SIZE_MAX);
    renderTable({ resetPage: true });
  };

  function mkBtn(text, { disabled = false, active = false, onClick } = {}) {
    const b = document.createElement("button");
    b.type = "button";
    b.textContent = text;
    if (active) b.classList.add("active");
    b.disabled = disabled;
    if (onClick) b.onclick = onClick;
    return b;
  }

  const firstBtn = mkBtn("首页", {
    disabled: currentPage <= 1 || totalItems === 0,
    onClick: () => { currentPage = 1; renderTable({ resetPage: false }); }
  });
  const prevBtn = mkBtn("上一页", {
    disabled: currentPage <= 1 || totalItems === 0,
    onClick: () => { currentPage -= 1; renderTable({ resetPage: false }); }
  });
  const nextBtn = mkBtn("下一页", {
    disabled: currentPage >= totalPages || totalItems === 0,
    onClick: () => { currentPage += 1; renderTable({ resetPage: false }); }
  });
  const lastBtn = mkBtn("末页", {
    disabled: currentPage >= totalPages || totalItems === 0,
    onClick: () => { currentPage = totalPages; renderTable({ resetPage: false }); }
  });

  // 页码按钮（最多显示 7 个）
  const maxButtons = 7;
  let startPage = Math.max(1, currentPage - 3);
  let endPage = Math.min(totalPages, startPage + maxButtons - 1);
  startPage = Math.max(1, endPage - maxButtons + 1);

  // 组合 UI
  controls.appendChild(sizeLabel);
  controls.appendChild(sizeSelect);
  controls.appendChild(firstBtn);
  controls.appendChild(prevBtn);

  for (let p = startPage; p <= endPage; p++) {
    controls.appendChild(mkBtn(String(p), {
      active: p === currentPage,
      disabled: totalItems === 0,
      onClick: () => { currentPage = p; renderTable({ resetPage: false }); }
    }));
  }

  controls.appendChild(nextBtn);
  controls.appendChild(lastBtn);

  // 跳转
  const jump = document.createElement("input");
  jump.type = "number";
  jump.min = "1";
  jump.max = String(totalPages);
  jump.placeholder = "页码";
  jump.value = "";
  jump.onkeydown = (e) => {
    if (e.key === "Enter") {
      const p = clamp(Number(jump.value) || 1, 1, totalPages);
      currentPage = p;
      renderTable({ resetPage: false });
      jump.value = "";
    }
  };

  const jumpBtn = mkBtn("跳转", {
    disabled: totalItems === 0,
    onClick: () => {
      const p = clamp(Number(jump.value) || 1, 1, totalPages);
      currentPage = p;
      renderTable({ resetPage: false });
      jump.value = "";
    }
  });

  controls.appendChild(jump);
  controls.appendChild(jumpBtn);

  el.appendChild(info);
  el.appendChild(controls);
}

    function refreshYearOptions() {
      const yearSelect = document.getElementById("yearSelect");
      const oldValue = activeYear;
      const years = Array.from(new Set(records.map(r => r.date.slice(0, 4)))).sort();
      yearSelect.innerHTML = '<option value="">全部年份</option>';
      years.forEach(y => {
        const opt = document.createElement("option");
        opt.value = y;
        opt.textContent = y;
        yearSelect.appendChild(opt);
      });
      if (oldValue && years.includes(oldValue)) {
        activeYear = oldValue;
        yearSelect.value = oldValue;
      } else {
        activeYear = "";
        yearSelect.value = "";
        activeMonth = "";
      }
      refreshMonthButtons();
    }

    function refreshMonthButtons() {
      const container = document.getElementById("monthButtons");
      container.innerHTML = "";

      const year = activeYear;
      const monthsHasData = {};
      records.forEach(r => {
        const y = r.date.slice(0, 4);
        const m = r.date.slice(5, 7);
        if (!year || y === year) {
          monthsHasData[m] = true;
        }
      });

      // 若当前月份在该年份下无数据，则自动回到“全部月份”
      if (activeMonth && !monthsHasData[activeMonth]) {
        activeMonth = "";
        saveViewState();
      }

      for (let i = 1; i <= 12; i++) {
        const m = String(i).padStart(2, "0");
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "month-btn";
        btn.textContent = i + "月";

        const hasData = monthsHasData[m];
        if (!hasData) {
          btn.classList.add("disabled");
          btn.onclick = null;
        } else {
          btn.onclick = () => setActiveMonth(m);
        }
        if (activeMonth === m) {
          btn.classList.add("active");
        }
        container.appendChild(btn);
      }

      // 增加一个“全部月份”按钮
      const allBtn = document.createElement("button");
      allBtn.type = "button";
      allBtn.className = "month-btn";
      allBtn.textContent = "全部月份";
      if (!activeMonth) {
        allBtn.classList.add("active");
      }
      allBtn.onclick = () => {
        activeMonth = "";
        saveViewState();
        renderTable();
      };
      container.appendChild(allBtn);
    }

    function onYearChange() {
      const select = document.getElementById("yearSelect");
      activeYear = select.value;
      activeMonth = ""; // 切换年份时重置月份
      saveViewState();
      renderTable();
    }

    function setActiveMonth(m) {
      if (activeMonth === m) {
        activeMonth = ""; // 再次点击可取消
      } else {
        activeMonth = m;
      }
      saveViewState();
      renderTable();
    }

    function updateStatsAndCharts(filtered) {
      const totalAll = records.length;
      const totalFiltered = filtered.length;

      const countsByType = {};
      const countsByMonth = {}; // yyyy-MM

      filtered.forEach(r => {
        const t = (r.type && String(r.type).trim()) ? String(r.type).trim() : "未分类";
        countsByType[t] = (countsByType[t] || 0) + 1;

        const monthKey = (r.date && String(r.date).length >= 7) ? String(r.date).slice(0, 7) : "未知月份";
        countsByMonth[monthKey] = (countsByMonth[monthKey] || 0) + 1;
      });

      // ===== 概览卡片 =====
      const typeKinds = Object.keys(countsByType).length;
      const topType = Object.entries(countsByType).sort((a,b) => b[1]-a[1])[0]?.[0] || "-";
      const topTypeCount = Object.entries(countsByType).sort((a,b) => b[1]-a[1])[0]?.[1] || 0;

      const cardsEl = document.getElementById("statsCards");
      if (cardsEl) {
        cardsEl.innerHTML = `
          <div class="stat">
            <div class="label">当前视图工单数</div>
            <div class="value">${totalFiltered}</div>
            <div class="sub">已应用筛选 + 年/月视图</div>
          </div>
          <div class="stat">
            <div class="label">全部工单数</div>
            <div class="value">${totalAll}</div>
            <div class="sub">本地存储/当前数据</div>
          </div>
          <div class="stat">
            <div class="label">类型数量</div>
            <div class="value">${typeKinds}</div>
            <div class="sub">Top：${escapeHtml(topType)}（${topTypeCount}）</div>
          </div>
        `;
      }

      // 兼容：老版本页面的 #stats（如果存在就也填一下，避免空白）
      const statsEl = document.getElementById("stats");
      if (statsEl) {
        statsEl.innerHTML = `<div class="muted">全部记录：${totalAll} 条；当前视图：${totalFiltered} 条。</div>`;
      }

      // ===== 颜色生成 =====
      function genColors(n) {
        const out = [];
        const base = 210; // 蓝系起点
        for (let i = 0; i < n; i++) {
          const hue = (base + i * (360 / Math.max(1, n))) % 360;
          out.push(`hsl(${hue} 75% 55%)`);
        }
        return out;
      }

      // ===== 自定义图例 =====
      function renderLegend(labels, values, colors) {
        const legend = document.getElementById("typeLegend");
        if (!legend) return;
        if (!labels.length) {
          legend.innerHTML = `<div class="muted">暂无数据</div>`;
          return;
        }
        const sum = values.reduce((a,b) => a + b, 0) || 1;
        legend.innerHTML = labels.map((name, idx) => {
          const v = values[idx] || 0;
          const pct = Math.round((v / sum) * 1000) / 10; // 1 位小数
          return `
            <div class="legend-item" title="${escapeHtml(name)}">
              <span class="legend-swatch" style="background:${colors[idx]};"></span>
              <span class="legend-name">${escapeHtml(name)}</span>
              <span class="legend-meta">
                <span class="legend-count">${v}</span>
                <span class="legend-pct">${pct}%</span>
              </span>
            </div>
          `;
        }).join("");
      }

      // ===== 饼图（类型分布）=====
      const pieLabels = Object.keys(countsByType);
      const pieData = pieLabels.map(l => countsByType[l]);
      const pieColors = genColors(pieLabels.length);

      if (typePieChart) typePieChart.destroy();
      const pieCanvas = document.getElementById("typePieChart");
      if (pieCanvas) {
        const pieCtx = pieCanvas.getContext("2d");
        typePieChart = new Chart(pieCtx, {
          type: "pie",
          data: {
            labels: pieLabels,
            datasets: [{
              data: pieData,
              backgroundColor: pieColors,
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    const v = ctx.parsed ?? 0;
                    const sum = pieData.reduce((a,b)=>a+b,0) || 1;
                    const pct = Math.round((v/sum)*1000)/10;
                    return `${ctx.label}: ${v}（${pct}%）`;
                  }
                }
              }
            }
          }
        });
      }
      renderLegend(pieLabels, pieData, pieColors);

      // ===== 柱状图（按月份数量）=====
      const monthKeys = Object.keys(countsByMonth).sort();
      const barLabels = monthKeys;
      const barData = monthKeys.map(k => countsByMonth[k]);

      if (monthBarChart) monthBarChart.destroy();
      const barCanvas = document.getElementById("monthBarChart");
      if (barCanvas) {
        const barCtx = barCanvas.getContext("2d");
        monthBarChart = new Chart(barCtx, {
          type: "bar",
          data: {
            labels: barLabels,
            datasets: [{
              label: "工单数量",
              data: barData,
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  title: (items) => items?.[0]?.label || "",
                  label: (ctx) => `数量：${ctx.parsed.y ?? 0}`
                }
              }
            },
            scales: {
              x: { title: { display: true, text: "月份" } },
              y: { title: { display: true, text: "工单数量" }, beginAtZero: true, ticks: { precision: 0 } }
            }
          }
        });
      }
    }


    
    // 生成「故障类型统计」Sheet：
    // - 默认：直接写入统计数值
    // - 若提供 dataSheetName：使用 Excel 公式（COUNTIF）动态统计（用户在 Excel 里改类型也会自动更新）
    function buildTypeStatsSheet(arr, dataSheetName) {
      const map = {};
      const safeArr = Array.isArray(arr) ? arr : [];
      safeArr.forEach(r => {
        const t = (r && r.type != null ? String(r.type) : "").trim() || "未分类";
        map[t] = (map[t] || 0) + 1;
      });

      const types = Object.entries(map).sort((a, b) => b[1] - a[1]).map(([t]) => t);
      const rows = [["故障类型", "数量", "占比"]];
      types.forEach(t => rows.push([t, null, null]));
      rows.push(["合计", null, null]);

      const ws = XLSX.utils.aoa_to_sheet(rows);
      ws["!cols"] = [{ wch: 26 }, { wch: 10 }, { wch: 12 }];

      const totalRowIdx = rows.length; // 1-based in Excel
      const firstDataRowIdx = 2;
      const lastTypeRowIdx = totalRowIdx - 1;

      if (dataSheetName) {
        // 类型列在第 7 列（G列）
        const typeRange = `'${dataSheetName.replace(/'/g, "''")}'!$G:$G`;

        for (let i = 0; i < types.length; i++) {
          const r = firstDataRowIdx + i; // Excel row number
          // B列数量：COUNTIF
          const cellB = XLSX.utils.encode_cell({ r: r - 1, c: 1 });
          ws[cellB] = ws[cellB] || { t: "n" };
          ws[cellB].f = `COUNTIF(${typeRange},A${r})`;

          // C列占比：B/合计
          const cellC = XLSX.utils.encode_cell({ r: r - 1, c: 2 });
          ws[cellC] = ws[cellC] || { t: "n" };
          ws[cellC].f = `IF($B$${totalRowIdx}=0,0,B${r}/$B$${totalRowIdx})`;
          ws[cellC].z = "0.0%";
        }

        // 合计行
        const totalB = XLSX.utils.encode_cell({ r: totalRowIdx - 1, c: 1 });
        ws[totalB] = ws[totalB] || { t: "n" };
        ws[totalB].f = `SUM(B${firstDataRowIdx}:B${lastTypeRowIdx})`;

        const totalC = XLSX.utils.encode_cell({ r: totalRowIdx - 1, c: 2 });
        ws[totalC] = ws[totalC] || { t: "n" };
        ws[totalC].f = `IF($B$${totalRowIdx}=0,0,1)`;
        ws[totalC].z = "0.0%";
      } else {
        // 静态写值（用于多 Sheet 汇总，避免跨 Sheet 公式复杂）
        const total = safeArr.length || 0;
        for (let i = 0; i < types.length; i++) {
          const t = types[i];
          const c = map[t] || 0;
          const row = firstDataRowIdx + i;

          const cellB = XLSX.utils.encode_cell({ r: row - 1, c: 1 });
          ws[cellB] = { t: "n", v: c };

          const cellC = XLSX.utils.encode_cell({ r: row - 1, c: 2 });
          ws[cellC] = { t: "n", v: total ? c / total : 0, z: "0.0%" };
        }
        const totalB = XLSX.utils.encode_cell({ r: totalRowIdx - 1, c: 1 });
        ws[totalB] = { t: "n", v: total };

        const totalC = XLSX.utils.encode_cell({ r: totalRowIdx - 1, c: 2 });
        ws[totalC] = { t: "n", v: total ? 1 : 0, z: "0.0%" };
      }

      return ws;
    }

    // 导出当前筛选为单 Sheet Excel
    function exportExcelCurrent() {
      const filtered = getFilteredRecords();
      if (filtered.length === 0) {
        showToast("当前视图下没有可导出的记录！", "warning");
        return;
      }
      const data = [["日期", "问题", "部门", "姓名", "处理方法", "备注", "类型" ]];
      filtered.forEach(r => {
        data.push([r.date, r.issue, r.department, r.name, r.solution, r.remarks, r.type]);
      });
      const ws = XLSX.utils.aoa_to_sheet(data);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "工单记录");
      
      // 追加：故障类型统计
      const wsStats = buildTypeStatsSheet(filtered, "工单记录");
      XLSX.utils.book_append_sheet(wb, wsStats, "类型统计");

      XLSX.writeFile(wb, "工单记录_当前视图.xlsx");
    }

    // 按月份分 Sheet 导出 Excel（基于全部 records，按 yyyy-MM 分页）
    function exportExcelByMonth() {
      if (records.length === 0) {
        showToast("没有可导出的数据！", "warning");
        return;
      }
      const grouped = {};
      records.forEach(r => {
        const monthKey = r.date.slice(0, 7); // yyyy-MM
        if (!grouped[monthKey]) grouped[monthKey] = [];
        grouped[monthKey].push(r);
      });
      const wb = XLSX.utils.book_new();
      Object.keys(grouped).sort().forEach(monthKey => {
        const arr = grouped[monthKey];
        const data = [["日期", "问题", "部门", "姓名", "处理方法", "备注", "类型" ]];
        arr.forEach(r => {
          data.push([r.date, r.issue, r.department, r.name, r.solution, r.remarks, r.type]);
        });
        const ws = XLSX.utils.aoa_to_sheet(data);
        const sheetName = monthKey.replace("-", ""); // 202501
        XLSX.utils.book_append_sheet(wb, ws, sheetName);
      });
      
      // 追加：故障类型统计（全量 records）
      const wsStats = buildTypeStatsSheet(records);
      XLSX.utils.book_append_sheet(wb, wsStats, "类型统计");

      XLSX.writeFile(wb, "工单记录_按月份多Sheet.xlsx");
    }

    // 导出 JSON 备份（包含：工单 + 回收站）
    async function backupData() {
      try {
        // GET 不需要口令
        const [resActive, resTrash] = await Promise.all([
          fetch("/api/tickets", { cache: "no-store" }),
          fetch("/api/tickets?trash=1", { cache: "no-store" }),
        ]);

        if (!resActive.ok) throw new Error(`active backup failed: ${resActive.status}`);
        // 回收站接口在未迁移 schema 时可能不存在 -> 允许为空
        const activeJson = await resActive.json();
        const active = Array.isArray(activeJson) ? activeJson : [];

        let trash = [];
        if (resTrash.ok) {
          const t = await resTrash.json();
          trash = Array.isArray(t) ? t : [];
        }

        const payload = {
          exported_at: new Date().toISOString(),
          active,
          trash,
        };

        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "工单备份_含回收站.json";
        link.click();
        URL.revokeObjectURL(url);
        showToast("备份成功！已下载 JSON 文件。", "success");
      } catch (e) {
        console.error(e);
        showToast("备份失败：请检查网络或后端是否正常。", "error");
      }
    }

    
    // 载入 JSON 备份（兼容多种导出格式）
    
// 载入 JSON 备份（兼容多种导出格式）
function loadBackup(event) {
  const input = event.target;
  const file = input && input.files ? input.files[0] : null;
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async function(e) {
    try {
      const raw = e.target.result;
      const parsed = JSON.parse(raw);

      // 新格式：{ active: [...], trash: [...] }
      let importedPayload = null;
      if (parsed && typeof parsed === "object" && (Array.isArray(parsed.active) || Array.isArray(parsed.trash))) {
        importedPayload = {
          active: Array.isArray(parsed.active) ? parsed.active : [],
          trash: Array.isArray(parsed.trash) ? parsed.trash : [],
        };
      }

      // 1) 最常见：直接是数组
      let imported = null;

      if (importedPayload) {
        // 本地展示默认导入到当前视图（工单/回收站）
        imported = viewMode === "trash" ? importedPayload.trash : importedPayload.active;
      }

      if (!importedPayload && Array.isArray(parsed)) {
        imported = parsed;
      } else if (!importedPayload && parsed && typeof parsed === "object") {
        // 2) 兼容：{ records: [...] } / { data: [...] } / { tickets: [...] }
        const candidate =
          (Array.isArray(parsed.records) && parsed.records) ||
          (Array.isArray(parsed.data) && parsed.data) ||
          (Array.isArray(parsed.tickets) && parsed.tickets) ||
          (Array.isArray(parsed.items) && parsed.items);

        if (candidate) {
          imported = candidate;
        } else {
          // 3) 兼容：按月份对象 { "2025-12": [ ... ], "2025-11": [ ... ] }
          const keys = Object.keys(parsed);
          const monthLike = keys.some(k => /^\d{4}-\d{2}$/.test(k) && Array.isArray(parsed[k]));
          if (monthLike) {
            imported = [];
            keys.sort().forEach(k => {
              if (Array.isArray(parsed[k])) imported = imported.concat(parsed[k]);
            });
          }
        }
      }

      if (!Array.isArray(imported)) {
        showToast("备份格式不正确：请导入通过本系统导出的 JSON 备份文件。", "error");
        return;
      }

      const normImported = normalizeRecords(imported);
      const normPayload = importedPayload ? {
        active: normalizeRecords(importedPayload.active),
        trash: normalizeRecords(importedPayload.trash),
      } : null;

      // 询问：导入到云端（共享）还是仅导入本地（当前浏览器）
      const toCloud = await showConfirm({
        title: "导入备份",
        message:
          "建议使用【合并导入】（不清空云端）。
" +
          "合并规则：仅当备份记录的 updated_at 更新更晚时才覆盖云端同 id 记录。

" +
          "- 确认：合并到云端（安全）
" +
          "- 取消：仅导入本地（只影响你当前浏览器）",
        confirmText: "合并到云端",
        cancelText: "仅本地导入",
        danger: false
      });

      if (toCloud) {
        // 1) 先预演（Dry-run），给出变更摘要
        const previewRes = await authedFetch("/api/import/preview", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(normPayload || normImported)
        });
        if (!previewRes.ok) throw new Error(`import preview failed: ${previewRes.status}`);
        const preview = await previewRes.json();
        const t = preview && preview.totals ? preview.totals : null;

        const msg =
          (t
            ? `预演结果：

` +
              `- 新增：${t.inserts} 条
` +
              `- 更新：${t.updates} 条（仅备份更晚才覆盖）
` +
              `- 跳过：${t.skips} 条（其中云端更新更晚/相等：${t.skipped_newer_or_equal} 条）
` +
              `- 输入：${t.incoming} 条（active ${t.active} / trash ${t.trash}）
`
            : "无法获取预演统计。
") +
          `
是否应用该导入？（不会清空云端）`;

        const apply = await showConfirm({
          title: "导入预演（安全合并）",
          message: msg,
          confirmText: "应用导入",
          cancelText: "取消",
          danger: false
        });

        if (!apply) {
          showToast("已取消导入。", "info");
          return;
        }

        // 2) 应用导入
        const applyRes = await authedFetch("/api/import/apply", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(normPayload || normImported)
        });
        if (!applyRes.ok) throw new Error(`import apply failed: ${applyRes.status}`);
        await reloadAndRender();
        showToast("已合并导入到云端（未清空）。", "success");
      } else {
        records = normImported;
        const allForMax = normPayload ? normPayload.active.concat(normPayload.trash) : records;
        const maxId = allForMax.reduce((max, r) => {
          const v = Number(r.id);
          return Number.isFinite(v) ? Math.max(max, v) : max;
        }, 0);
        nextId = maxId + 1;
        currentPage = 1;
        refreshYearOptions();
        renderTable();
        saveToLocal();
        showToast(`已导入到本地（共 ${records.length} 条，仅本浏览器）！`, "success");
      }
    } catch (err) {
      if (isNoKeyError(err)) return;
      console.error(err);
      if (err instanceof SyntaxError) {
        showToast("解析备份失败：文件不是有效的 JSON。", "error");
      } else {
        showToast("导入失败：请检查备份文件或后端是否正常。", "error");
      }
    } finally {
      if (input) input.value = "";
    }
  };

  reader.onerror = function() {
    showToast("读取文件失败，请重试。", "error");
    if (input) input.value = "";
  };

  reader.readAsText(file);
}

    // 按月份导出 JSON（每个月一个独立 JSON 文件）
    function archiveByMonthJSON() {
      if (records.length === 0) {
        showToast("没有可归档的数据！", "warning");
        return;
      }
      const groups = {};
      records.forEach(r => {
        const monthKey = r.date.slice(0, 7); // yyyy-MM
        if (!groups[monthKey]) groups[monthKey] = [];
        groups[monthKey].push(r);
      });
      Object.keys(groups).sort().forEach(monthKey => {
        const data = groups[monthKey];
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `工单_${monthKey}.json`;
        a.click();
        URL.revokeObjectURL(url);
      });
      showToast("所有月份已分别导出为独立 JSON 文件！", "success");
    }

    // 年度 ZIP 打包：所有月份 JSON 文件打包为一个 ZIP
    function exportYearZip() {
      if (records.length === 0) {
        showToast("没有可打包的数据！", "warning");
        return;
      }
      const zip = new JSZip();
      const groups = {};
      records.forEach(r => {
        const monthKey = r.date.slice(0, 7); // yyyy-MM
        if (!groups[monthKey]) groups[monthKey] = [];
        groups[monthKey].push(r);
      });
      Object.keys(groups).sort().forEach(monthKey => {
        const data = groups[monthKey];
        const content = JSON.stringify(data, null, 2);
        zip.file(`工单_${monthKey}.json`, content);
      });
      zip.generateAsync({ type: "blob" }).then(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "工单年度归档.zip";
        a.click();
        URL.revokeObjectURL(url);
      });
    }

    // 初始化
    
(async function init() {
  try { updateEditKeyStatus(); } catch (e) {}

  // 先恢复月份视图（只影响筛选/显示，不影响数据源）
  loadViewState();

  // 恢复视图模式（工单 / 回收站）
  loadViewMode();
  updateViewModeUI();

  // 先尝试从云端加载（多人共享数据）
  try {
    await reloadAndRender({ showLoadedToast: false });
  } catch (e) {
    console.error(e);
    // 云端失败时用本地缓存兜底
    loadFromLocal();
    refreshYearOptions();
    renderTable();
    showToast("云端加载失败，已使用本地缓存（仅本浏览器）。", "warning");
  }
})();
  </script>
<!-- Toast 提示 -->
<div aria-atomic="true" aria-live="polite" class="toast-container" id="toastContainer"></div>
<!-- 通用弹窗（替代 alert/confirm） -->
<div aria-hidden="true" aria-modal="true" class="modal-overlay" id="modalOverlay" role="dialog">
<div class="modal" role="document">
<div class="modal-header">
<div class="modal-title" id="modalTitle">提示</div>
</div>
<div class="modal-body" id="modalBody"></div>
<div class="modal-footer" id="modalFooter"></div>
</div>
</div>
<script>
  // 手动选择目录并导出 JSON 备份（使用统一 Toast 提示）
  async function manualBackup() {
    if (!window.showDirectoryPicker) {
      showToast("当前浏览器不支持目录访问 API，建议使用最新版的 Edge/Chrome。", "warning");
      return;
    }
    if (!records || records.length === 0) {
      showToast("当前没有可备份的数据！", "warning");
      return;
    }

    try {
      const dir = await window.showDirectoryPicker();
      const today = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
      const fileName = `工单备份_${today}.json`;
      const fileHandle = await dir.getFileHandle(fileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(records, null, 2));
      await writable.close();

      showToast("备份成功！", "success");
    } catch (e) {
      if (e && e.name === "AbortError") {
        // 用户取消选择，静默即可
        return;
      }
      console.error(e);
      showToast("备份失败！", "error");
    }
  }
</script>
</body>
</html>
